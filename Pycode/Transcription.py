import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import os
import threading
import time
import json
from datetime import datetime, timedelta
from pathlib import Path
import sys
import io
import re
import queue
import subprocess
import platform

# Dynamic library loading configuration
PYTORCH_DIR = Path("pytorch_libs")
WHISPER_AVAILABLE = False
whisper = None
torch = None

def setup_pytorch_path():
    """Setup PyTorch library path for dynamic loading"""
    global WHISPER_AVAILABLE, whisper, torch
    
    if getattr(sys, 'frozen', False):
        base_path = Path(sys.executable).parent
    else:
        base_path = Path(__file__).parent
    
    PYTORCH_DIR = base_path / "pytorch_libs"
    
    if PYTORCH_DIR.exists():
        pytorch_path = str(PYTORCH_DIR.absolute())
        if pytorch_path not in sys.path:
            sys.path.insert(0, pytorch_path)
        
        try:
            import torch as torch_module
            import whisper as whisper_module
            torch = torch_module
            whisper = whisper_module
            WHISPER_AVAILABLE = True
            print(f"Successfully loaded PyTorch from: {pytorch_path}")
            return True
        except ImportError as e:
            print(f"Failed to import PyTorch/Whisper: {e}")
            return False
    else:
        print(f"PyTorch directory not found at: {PYTORCH_DIR}")
    return False

class ProgressCapture(io.StringIO):
    """Custom StringIO class to capture and parse Whisper progress output"""
    def __init__(self, callback, segment_callback=None, text_callback=None):
        super().__init__()
        self.callback = callback
        self.segment_callback = segment_callback
        self.text_callback = text_callback
        self.buffer = ""
        self.current_segment = ""
        
    def write(self, text):
        super().write(text)
        self.buffer += text
        self.current_segment += text
    
        lines = self.current_segment.split('\n')
        complete = lines[:-1]
        self.current_segment = lines[-1]
        
        for line in complete:
            self.process_line(line)
    
        return len(text)
    
    def process_line(self, text):
        """Process a line of text for patterns"""
        progress_pattern = r'(\d+)%\s*\|[^|]*\|\s*(\d+)/(\d+)'
        match = re.search(progress_pattern, text)
        
        if match:
            percentage = int(match.group(1))
            current_frames = int(match.group(2))
            total_frames = int(match.group(3))
            
            time_pattern = r'\[(\d+:\d+)<(\d+:\d+),'
            time_match = re.search(time_pattern, text)
            
            elapsed_str = ""
            remaining_str = ""
            
            if time_match:
                elapsed_str = time_match.group(1)
                remaining_str = time_match.group(2)
            
            if self.callback:
                self.callback(percentage, current_frames, total_frames, elapsed_str, remaining_str)
        
        segment_pattern = r'\[(\d{2}:\d{2}\.\d{3}) --> (\d{2}:\d{2}\.\d{3})\]\s*(.+?)(?=\n|\Z)'
        segment_matches = re.finditer(segment_pattern, text, re.DOTALL)
        
        for segment_match in segment_matches:
            start_time_str = segment_match.group(1)
            end_time_str = segment_match.group(2)
            segment_text = segment_match.group(3).strip()
            
            def time_str_to_seconds(time_str):
                parts = time_str.split(':')
                minutes = int(parts[0])
                seconds = float(parts[1])
                return minutes * 60 + seconds
            
            end_seconds = time_str_to_seconds(end_time_str)
            
            if self.segment_callback:
                self.segment_callback(end_seconds)
            
            if self.text_callback and segment_text:
                self.text_callback(start_time_str, end_time_str, segment_text)

class AudioSubtitleSystem:
    """Audio Transcription System with multilingual support and responsive design"""
    def __init__(self):
        # State management
        self.current_file = None
        self.transcription_results = []
        self.whisper_model = None
        self.device = "cuda"
        self.audio_duration = 0
        self.transcription_start_time = None
        self.is_transcribing = False
        self.is_downloading = False
        self.is_loading_model = False
        self.update_timer = None
        self.original_stderr = None
        self.message_queue = queue.Queue()
        self.status_queue = queue.Queue()
        self.current_language = "en"  # Default language
        
        # Initialize translations
        self.init_translations()
        
        # Model processing speed factors
        self.model_speed_factors = {
            "tiny": 0.5,
            "base": 0.8,
            "small": 1.2,
            "medium": 2.0,
            "large": 3.5,
            "large-v2": 3.5,
            "large-v3": 3.5,
            "large-v3-turbo": 2.5
        }
        
        # Color theme
        self.colors = {
            'primary': '#2E3440',
            'accent': '#5E81AC',
            'success': '#A3BE8C',
            'warning': '#EBCB8B',
            'danger': '#BF616A',
            'text': '#2E3440',
            'text_light': '#4C566A',
            'background': '#ECEFF4',
            'surface': '#FFFFFF',
            'border': '#D8DEE9'
        }

        # Check for PyTorch/Whisper availability
        self.check_dependencies()
        
        # Setup GUI with responsive design
        self.setup_responsive_gui()

    def init_translations(self):
        """Initialize all UI text translations"""
        self.translations = {
            "en": {
                "window_title": "Audio Subtitle System",
                "header_title": "Audio Subtitle System",
                "header_subtitle": "Audio Transcription & Subtitle Generation",
                "language": "Language:",
                "audio_file_selection": "Audio File Selection:",
                "select_file": "üìÅ Select Audio File",
                "start_transcription": "üéØ Start Transcription",
                "no_file_selected": "No file selected",
                "adjust_parameters": "‚öôÔ∏è Adjust Parameters",
                "parameter_settings": "Parameter Settings",
                "ok": "OK",
                "parameters_updated": "Parameters updated:",
                "dependency_warning": "‚ö†Ô∏è PyTorch/Whisper Not Installed",
                "dependency_message": "Please run PyTorch Downloader to install required dependencies",
                "run_downloader": "üîß Run PyTorch Downloader",
                "recheck": "üîÑ Recheck",
                "whisper_model": "Whisper Model Selection:",
                "keyword_optional": "Keyword (Optional):",
                "transcription_language": "Transcription Language:",
                "system_status": "System Status:",
                "waiting_to_start": "Waiting to Start",
                "elapsed": "Elapsed:",
                "duration": "Duration:",
                "transcription_output": "Transcription Output:",
                "clear": "üóëÔ∏è Clear",
                "save_transcription": "üíæ Save Transcription",
                "save_subtitle": "üé¨ Save Subtitle File",
                "warning": "Warning",
                "error": "Error",
                "success": "Success",
                "info": "Info",
                "confirm": "Confirm",
                "please_select_audio": "Please select an audio file",
                "whisper_not_installed": "Whisper not installed, please run PyTorch Downloader first",
                "starting_transcription": "Starting audio transcription...",
                "preparing": "Preparing...",
                "transcription_complete": "Transcription complete! Segments: {}, Processing time: {}",
                "transcription_completed": "Transcription completed",
                "transcription_success": "Transcription completed successfully",
                "transcription_error": "Transcription error:",
                "model_download_confirm": "{} model ({}) not found. Download now?",
                "model_download_title": "Download Model?",
                "model_download_cancelled": "Model download cancelled",
                "downloading_model": "Downloading model: {} ({})",
                "loading_model": "Loading model: {}",
                "model_loaded": "Model '{}' loaded successfully (Device: {})",
                "model_loading_error": "Model loading error",
                "model_loading_failed": "Model loading failed:",
                "downloader_launched": "PyTorch Downloader launched",
                "downloader_launch_failed": "Failed to launch downloader:",
                "downloader_not_found": "Cannot find pytorch_downloader.exe or .py",
                "dependencies_loaded": "PyTorch/Whisper loaded successfully!",
                "dependencies_not_installed": "PyTorch/Whisper still not installed",
                "no_results_to_save": "No transcription results to save",
                "save_as": "Save As",
                "results_saved": "Transcription results saved:",
                "subtitle_saved": "Subtitle file saved:",
                "save_error": "Save error:",
                "no_subtitles": "No subtitles to save",
                "file_selected": "Audio file selected: {} (Estimated time: {})",
                "file_selected_no_duration": "Audio file selected: {} (Whisper not installed, cannot get duration)",
                "model_not_found": "Model '{}' not found. Checking download...",
                "confirming_download": "Confirming model download: {}",
                "unable_to_get_duration": "Unable to get audio duration:",
                "downloading": "Downloading model '{}' (Size: {})",
                "loading": "Loading model '{}'...",
                "language_codes": {
                    "ja": "Japanese",
                    "en": "English", 
                    "zh": "Chinese",
                    "ko": "Korean",
                    "es": "Spanish",
                    "fr": "French",
                    "de": "German",
                    "ru": "Russian",
                    "auto": "Auto-detect"
                }
            },
            "ja": {
                "window_title": "Èü≥Â£∞Â≠óÂπï„Ç∑„Çπ„ÉÜ„É†",
                "header_title": "Èü≥Â£∞Â≠óÂπï„Ç∑„Çπ„ÉÜ„É†",
                "header_subtitle": "Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅÆËª¢ÂÜô„Å®Â≠óÂπïÁîüÊàê",
                "language": "Ë®ÄË™û:",
                "audio_file_selection": "Èü≥Â£∞„Éï„Ç°„Ç§„É´ÈÅ∏Êäû:",
                "select_file": "üìÅ „Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû",
                "start_transcription": "üéØ Ëª¢ÂÜôÈñãÂßã",
                "no_file_selected": "„Éï„Ç°„Ç§„É´Êú™ÈÅ∏Êäû",
                "adjust_parameters": "‚öôÔ∏è Ë™øÊï¥„Éë„É©„É°„Éº„Çø",
                "parameter_settings": "„Éë„É©„É°„Éº„ÇøË®≠ÂÆö",
                "ok": "OK",
                "parameters_updated": "„Éë„É©„É°„Éº„ÇøÊõ¥Êñ∞Ê∏à„Åø:",
                "dependency_warning": "‚ö†Ô∏è PyTorch/Whisper„Åå„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
                "dependency_message": "ÂøÖË¶Å„Å™‰æùÂ≠òÈñ¢‰øÇ„Çí„Ç§„É≥„Çπ„Éà„Éº„É´„Åô„Çã„Å´„ÅØPyTorch„ÉÄ„Ç¶„É≥„É≠„Éº„ÉÄ„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                "run_downloader": "üîß PyTorch„ÉÄ„Ç¶„É≥„É≠„Éº„ÉÄ„ÇíÂÆüË°å",
                "recheck": "üîÑ ÂÜç„ÉÅ„Çß„ÉÉ„ÇØ",
                "whisper_model": "Whisper„É¢„Éá„É´ÈÅ∏Êäû:",
                "keyword_optional": "„Ç≠„Éº„ÉØ„Éº„Éâ („Ç™„Éó„Ç∑„Éß„É≥):",
                "transcription_language": "Ëª¢ÂÜôË®ÄË™û:",
                "system_status": "„Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã:",
                "waiting_to_start": "ÈñãÂßãÂæÖ„Å°",
                "elapsed": "ÁµåÈÅéÊôÇÈñì:",
                "duration": "Èü≥Â£∞Èï∑„Åï:",
                "transcription_output": "Ëª¢ÂÜôÁµêÊûú:",
                "clear": "üóëÔ∏è „ÇØ„É™„Ç¢",
                "save_transcription": "üíæ Ëª¢ÂÜôÁµêÊûú„Çí‰øùÂ≠ò",
                "save_subtitle": "üé¨ Â≠óÂπï„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò",
                "warning": "Ë≠¶Âëä",
                "error": "„Ç®„É©„Éº",
                "success": "ÊàêÂäü",
                "info": "ÊÉÖÂ†±",
                "confirm": "Á¢∫Ë™ç",
                "please_select_audio": "Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                "whisper_not_installed": "Whisper„Åå„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂÖà„Å´PyTorch„ÉÄ„Ç¶„É≥„É≠„Éº„ÉÄ„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                "starting_transcription": "Èü≥Â£∞„ÅÆËª¢ÂÜô„ÇíÈñãÂßã„Åó„Åæ„Åô...",
                "preparing": "Ê∫ñÂÇô‰∏≠...",
                "transcription_complete": "Ëª¢ÂÜô„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ „Çª„Ç∞„É°„É≥„ÉàÊï∞: {}, Âá¶ÁêÜÊôÇÈñì: {}",
                "transcription_completed": "Ëª¢ÂÜôÂÆå‰∫Ü",
                "transcription_success": "Ëª¢ÂÜô„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü",
                "transcription_error": "Ëª¢ÂÜô„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:",
                "model_download_confirm": "{}„É¢„Éá„É´({})„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åô„ÅãÔºü",
                "model_download_title": "„É¢„Éá„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åô„ÅãÔºü",
                "model_download_cancelled": "„É¢„Éá„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
                "downloading_model": "„É¢„Éá„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ‰∏≠: {} ({})",
                "loading_model": "„É¢„Éá„É´Ë™≠„ÅøËæº„Åø‰∏≠: {}",
                "model_loaded": "„É¢„Éá„É´'{}'„ÅÆË™≠„ÅøËæº„Åø„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü („Éá„Éê„Ç§„Çπ: {})",
                "model_loading_error": "„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº",
                "model_loading_failed": "„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:",
                "downloader_launched": "PyTorch„ÉÄ„Ç¶„É≥„É≠„Éº„ÉÄ„ÇíËµ∑Âãï„Åó„Åæ„Åó„Åü",
                "downloader_launch_failed": "„ÉÄ„Ç¶„É≥„É≠„Éº„ÉÄ„ÇíËµ∑Âãï„Åß„Åç„Åæ„Åõ„Çì:",
                "downloader_not_found": "pytorch_downloader.exe„Åæ„Åü„ÅØ.py„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
                "dependencies_loaded": "PyTorch/Whisper„ÅåÊ≠£Â∏∏„Å´„É≠„Éº„Éâ„Åï„Çå„Åæ„Åó„ÅüÔºÅ",
                "dependencies_not_installed": "PyTorch/Whisper„ÅØ„Åæ„Å†„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
                "no_results_to_save": "‰øùÂ≠ò„Åô„ÇãËª¢ÂÜôÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì",
                "save_as": "ÂêçÂâç„Çí‰ªò„Åë„Å¶‰øùÂ≠ò",
                "results_saved": "Ëª¢ÂÜôÁµêÊûú„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü:",
                "subtitle_saved": "Â≠óÂπï„Éï„Ç°„Ç§„É´„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü:",
                "save_error": "‰øùÂ≠ò„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:",
                "no_subtitles": "‰øùÂ≠ò„Åô„ÇãÂ≠óÂπï„Åå„ÅÇ„Çä„Åæ„Åõ„Çì",
                "file_selected": "Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Åæ„Åó„Åü: {} (Êé®ÂÆöÊôÇÈñì: {})",
                "file_selected_no_duration": "Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Åæ„Åó„Åü: {} (Whisper„Åå„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅÈï∑„ÅïÂèñÂæó‰∏çÂèØ)",
                "model_not_found": "„É¢„Éá„É´'{}'„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÁ¢∫Ë™ç‰∏≠...",
                "confirming_download": "„É¢„Éá„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÁ¢∫Ë™ç‰∏≠: {}",
                "unable_to_get_duration": "Èü≥Â£∞Èï∑„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì:",
                "downloading": "„É¢„Éá„É´'{}'„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶„ÅÑ„Åæ„Åô... („Çµ„Ç§„Ç∫: {})",
                "loading": "„É¢„Éá„É´'{}'„ÇíË™≠„ÅøËæº„Åø‰∏≠...",
                "language_codes": {
                    "ja": "Êó•Êú¨Ë™û",
                    "en": "Ëã±Ë™û",
                    "zh": "‰∏≠ÂõΩË™û",
                    "ko": "ÈüìÂõΩË™û",
                    "es": "„Çπ„Éö„Ç§„É≥Ë™û",
                    "fr": "„Éï„É©„É≥„ÇπË™û",
                    "de": "„Éâ„Ç§„ÉÑË™û",
                    "ru": "„É≠„Ç∑„Ç¢Ë™û",
                    "auto": "Ëá™ÂãïÊ§úÂá∫"
                }
            },
            "zh": {
                "window_title": "Èü≥È¢ëÂ≠óÂπïÁ≥ªÁªü",
                "header_title": "Èü≥È¢ëÂ≠óÂπïÁ≥ªÁªü",
                "header_subtitle": "Èü≥È¢ëËΩ¨ÂΩïÂíåÂ≠óÂπïÁîüÊàê",
                "language": "ËØ≠Ë®Ä:",
                "audio_file_selection": "Èü≥È¢ëÊñá‰ª∂ÈÄâÊã©:",
                "select_file": "üìÅ ÈÄâÊã©Èü≥È¢ëÊñá‰ª∂",
                "start_transcription": "üéØ ÂºÄÂßãËΩ¨ÂΩï",
                "no_file_selected": "Êú™ÈÄâÊã©Êñá‰ª∂",
                "adjust_parameters": "‚öôÔ∏è Ë∞ÉÊï¥ÂèÇÊï∞",
                "parameter_settings": "ÂèÇÊï∞ËÆæÁΩÆ",
                "ok": "Á°ÆÂÆö",
                "parameters_updated": "ÂèÇÊï∞Â∑≤Êõ¥Êñ∞:",
                "dependency_warning": "‚ö†Ô∏è PyTorch/Whisper Êú™ÂÆâË£Ö",
                "dependency_message": "ËØ∑ËøêË°å PyTorch ‰∏ãËΩΩÂô®‰ª•ÂÆâË£ÖÊâÄÈúÄÁöÑ‰æùËµñÈ°π",
                "run_downloader": "üîß ËøêË°å PyTorch ‰∏ãËΩΩÂô®",
                "recheck": "üîÑ ÈáçÊñ∞Ê£ÄÊü•",
                "whisper_model": "Whisper Ê®°ÂûãÈÄâÊã©:",
                "keyword_optional": "ÂÖ≥ÈîÆËØç (ÂèØÈÄâ):",
                "transcription_language": "ËΩ¨ÂΩïËØ≠Ë®Ä:",
                "system_status": "Á≥ªÁªüÁä∂ÊÄÅ:",
                "waiting_to_start": "Á≠âÂæÖÂºÄÂßã",
                "elapsed": "Â∑≤Áî®Êó∂Èó¥:",
                "duration": "Èü≥È¢ëÊó∂Èïø:",
                "transcription_output": "ËΩ¨ÂΩïËæìÂá∫:",
                "clear": "üóëÔ∏è Ê∏ÖÈô§",
                "save_transcription": "üíæ ‰øùÂ≠òËΩ¨ÂΩïÁªìÊûú",
                "save_subtitle": "üé¨ ‰øùÂ≠òÂ≠óÂπïÊñá‰ª∂",
                "warning": "Ë≠¶Âëä",
                "error": "ÈîôËØØ",
                "success": "ÊàêÂäü",
                "info": "‰ø°ÊÅØ",
                "confirm": "Á°ÆËÆ§",
                "please_select_audio": "ËØ∑ÈÄâÊã©Èü≥È¢ëÊñá‰ª∂",
                "whisper_not_installed": "Whisper Êú™ÂÆâË£ÖÔºåËØ∑ÂÖàËøêË°å PyTorch ‰∏ãËΩΩÂô®",
                "starting_transcription": "ÂºÄÂßãÈü≥È¢ëËΩ¨ÂΩï...",
                "preparing": "ÂáÜÂ§á‰∏≠...",
                "transcription_complete": "ËΩ¨ÂΩïÂÆåÊàêÔºÅÁâáÊÆµÊï∞: {}ÔºåÂ§ÑÁêÜÊó∂Èó¥: {}",
                "transcription_completed": "ËΩ¨ÂΩïÂÆåÊàê",
                "transcription_success": "ËΩ¨ÂΩïÊàêÂäüÂÆåÊàê",
                "transcription_error": "ËΩ¨ÂΩïÈîôËØØ:",
                "model_download_confirm": "{} Ê®°Âûã ({}) Êú™ÊâæÂà∞„ÄÇÁé∞Âú®‰∏ãËΩΩÂêóÔºü",
                "model_download_title": "‰∏ãËΩΩÊ®°ÂûãÔºü",
                "model_download_cancelled": "Ê®°Âûã‰∏ãËΩΩÂ∑≤ÂèñÊ∂à",
                "downloading_model": "Ê≠£Âú®‰∏ãËΩΩÊ®°Âûã: {} ({})",
                "loading_model": "Ê≠£Âú®Âä†ËΩΩÊ®°Âûã: {}",
                "model_loaded": "Ê®°Âûã '{}' Âä†ËΩΩÊàêÂäü (ËÆæÂ§á: {})",
                "model_loading_error": "Ê®°ÂûãÂä†ËΩΩÈîôËØØ",
                "model_loading_failed": "Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•:",
                "downloader_launched": "PyTorch ‰∏ãËΩΩÂô®Â∑≤ÂêØÂä®",
                "downloader_launch_failed": "Êó†Ê≥ïÂêØÂä®‰∏ãËΩΩÂô®:",
                "downloader_not_found": "Êâæ‰∏çÂà∞ pytorch_downloader.exe Êàñ .py",
                "dependencies_loaded": "PyTorch/Whisper Âä†ËΩΩÊàêÂäüÔºÅ",
                "dependencies_not_installed": "PyTorch/Whisper ‰ªçÊú™ÂÆâË£Ö",
                "no_results_to_save": "Ê≤°ÊúâË¶Å‰øùÂ≠òÁöÑËΩ¨ÂΩïÁªìÊûú",
                "save_as": "Âè¶Â≠ò‰∏∫",
                "results_saved": "ËΩ¨ÂΩïÁªìÊûúÂ∑≤‰øùÂ≠ò:",
                "subtitle_saved": "Â≠óÂπïÊñá‰ª∂Â∑≤‰øùÂ≠ò:",
                "save_error": "‰øùÂ≠òÈîôËØØ:",
                "no_subtitles": "Ê≤°ÊúâË¶Å‰øùÂ≠òÁöÑÂ≠óÂπï",
                "file_selected": "Â∑≤ÈÄâÊã©Èü≥È¢ëÊñá‰ª∂: {} (È¢ÑËÆ°Êó∂Èó¥: {})",
                "file_selected_no_duration": "Â∑≤ÈÄâÊã©Èü≥È¢ëÊñá‰ª∂: {} (Whisper Êú™ÂÆâË£ÖÔºåÊó†Ê≥ïËé∑ÂèñÊó∂Èïø)",
                "model_not_found": "Êú™ÊâæÂà∞Ê®°Âûã '{}'„ÄÇÊ≠£Âú®Ê£ÄÊü•‰∏ãËΩΩ...",
                "confirming_download": "Á°ÆËÆ§Ê®°Âûã‰∏ãËΩΩ: {}",
                "unable_to_get_duration": "Êó†Ê≥ïËé∑ÂèñÈü≥È¢ëÊó∂Èïø:",
                "downloading": "Ê≠£Âú®‰∏ãËΩΩÊ®°Âûã '{}' (Â§ßÂ∞è: {})",
                "loading": "Ê≠£Âú®Âä†ËΩΩÊ®°Âûã '{}'...",
                "language_codes": {
                    "ja": "Êó•ËØ≠",
                    "en": "Ëã±ËØ≠",
                    "zh": "‰∏≠Êñá",
                    "ko": "Èü©ËØ≠",
                    "es": "Ë•øÁè≠ÁâôËØ≠",
                    "fr": "Ê≥ïËØ≠",
                    "de": "Âæ∑ËØ≠",
                    "ru": "‰øÑËØ≠",
                    "auto": "Ëá™Âä®Ê£ÄÊµã"
                }
            },
            "ko": {
                "window_title": "Ïò§ÎîîÏò§ ÏûêÎßâ ÏãúÏä§ÌÖú",
                "header_title": "Ïò§ÎîîÏò§ ÏûêÎßâ ÏãúÏä§ÌÖú",
                "header_subtitle": "Ïò§ÎîîÏò§ Ï†ÑÏÇ¨ Î∞è ÏûêÎßâ ÏÉùÏÑ±",
                "language": "Ïñ∏Ïñ¥:",
                "audio_file_selection": "Ïò§ÎîîÏò§ ÌååÏùº ÏÑ†ÌÉù:",
                "select_file": "üìÅ Ïò§ÎîîÏò§ ÌååÏùº ÏÑ†ÌÉù",
                "start_transcription": "üéØ Ï†ÑÏÇ¨ ÏãúÏûë",
                "no_file_selected": "ÌååÏùºÏù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùå",
                "adjust_parameters": "‚öôÔ∏è Îß§Í∞úÎ≥ÄÏàò Ï°∞Ï†ï",
                "parameter_settings": "Îß§Í∞úÎ≥ÄÏàò ÏÑ§Ï†ï",
                "ok": "ÌôïÏù∏",
                "parameters_updated": "Îß§Í∞úÎ≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏Îê®:",
                "dependency_warning": "‚ö†Ô∏è PyTorch/WhisperÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå",
                "dependency_message": "ÌïÑÏöîÌïú Ï¢ÖÏÜçÏÑ±ÏùÑ ÏÑ§ÏπòÌïòÎ†§Î©¥ PyTorch Îã§Ïö¥Î°úÎçîÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî",
                "run_downloader": "üîß PyTorch Îã§Ïö¥Î°úÎçî Ïã§Ìñâ",
                "recheck": "üîÑ Îã§Ïãú ÌôïÏù∏",
                "whisper_model": "Whisper Î™®Îç∏ ÏÑ†ÌÉù:",
                "keyword_optional": "ÌÇ§ÏõåÎìú (ÏÑ†ÌÉù ÏÇ¨Ìï≠):",
                "transcription_language": "Ï†ÑÏÇ¨ Ïñ∏Ïñ¥:",
                "system_status": "ÏãúÏä§ÌÖú ÏÉÅÌÉú:",
                "waiting_to_start": "ÏãúÏûë ÎåÄÍ∏∞ Ï§ë",
                "elapsed": "Í≤ΩÍ≥º ÏãúÍ∞Ñ:",
                "duration": "Ïò§ÎîîÏò§ Í∏∏Ïù¥:",
                "transcription_output": "Ï†ÑÏÇ¨ Ï∂úÎ†•:",
                "clear": "üóëÔ∏è ÏßÄÏö∞Í∏∞",
                "save_transcription": "üíæ Ï†ÑÏÇ¨ Í≤∞Í≥º Ï†ÄÏû•",
                "save_subtitle": "üé¨ ÏûêÎßâ ÌååÏùº Ï†ÄÏû•",
                "warning": "Í≤ΩÍ≥†",
                "error": "Ïò§Î•ò",
                "success": "ÏÑ±Í≥µ",
                "info": "Ï†ïÎ≥¥",
                "confirm": "ÌôïÏù∏",
                "please_select_audio": "Ïò§ÎîîÏò§ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî",
                "whisper_not_installed": "WhisperÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î®ºÏ†Ä PyTorch Îã§Ïö¥Î°úÎçîÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî",
                "starting_transcription": "Ïò§ÎîîÏò§ Ï†ÑÏÇ¨Î•º ÏãúÏûëÌï©ÎãàÎã§...",
                "preparing": "Ï§ÄÎπÑ Ï§ë...",
                "transcription_complete": "Ï†ÑÏÇ¨ ÏôÑÎ£å! ÏÑ∏Í∑∏Î®ºÌä∏: {}, Ï≤òÎ¶¨ ÏãúÍ∞Ñ: {}",
                "transcription_completed": "Ï†ÑÏÇ¨ ÏôÑÎ£å",
                "transcription_success": "Ï†ÑÏÇ¨Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§",
                "transcription_error": "Ï†ÑÏÇ¨ Ïò§Î•ò:",
                "model_download_confirm": "{} Î™®Îç∏ ({})ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏßÄÍ∏à Îã§Ïö¥Î°úÎìúÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
                "model_download_title": "Î™®Îç∏ Îã§Ïö¥Î°úÎìú?",
                "model_download_cancelled": "Î™®Îç∏ Îã§Ïö¥Î°úÎìúÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§",
                "downloading_model": "Î™®Îç∏ Îã§Ïö¥Î°úÎìú Ï§ë: {} ({})",
                "loading_model": "Î™®Îç∏ Î°úÎìú Ï§ë: {}",
                "model_loaded": "'{}' Î™®Îç∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêòÏóàÏäµÎãàÎã§ (Ïû•Ïπò: {})",
                "model_loading_error": "Î™®Îç∏ Î°úÎìú Ïò§Î•ò",
                "model_loading_failed": "Î™®Îç∏ Î°úÎìú Ïã§Ìå®:",
                "downloader_launched": "PyTorch Îã§Ïö¥Î°úÎçîÍ∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§",
                "downloader_launch_failed": "Îã§Ïö¥Î°úÎçîÎ•º ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§:",
                "downloader_not_found": "pytorch_downloader.exe ÎòêÎäî .pyÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
                "dependencies_loaded": "PyTorch/WhisperÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêòÏóàÏäµÎãàÎã§!",
                "dependencies_not_installed": "PyTorch/WhisperÍ∞Ä ÏïÑÏßÅ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§",
                "no_results_to_save": "Ï†ÄÏû•Ìï† Ï†ÑÏÇ¨ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§",
                "save_as": "Îã§Î•∏ Ïù¥Î¶ÑÏúºÎ°ú Ï†ÄÏû•",
                "results_saved": "Ï†ÑÏÇ¨ Í≤∞Í≥º Ï†ÄÏû•Îê®:",
                "subtitle_saved": "ÏûêÎßâ ÌååÏùº Ï†ÄÏû•Îê®:",
                "save_error": "Ï†ÄÏû• Ïò§Î•ò:",
                "no_subtitles": "Ï†ÄÏû•Ìï† ÏûêÎßâÏù¥ ÏóÜÏäµÎãàÎã§",
                "file_selected": "Ïò§ÎîîÏò§ ÌååÏùº ÏÑ†ÌÉùÎê®: {} (ÏòàÏÉÅ ÏãúÍ∞Ñ: {})",
                "file_selected_no_duration": "Ïò§ÎîîÏò§ ÌååÏùº ÏÑ†ÌÉùÎê®: {} (WhisperÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïÑ Í∏∏Ïù¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏùå)",
                "model_not_found": "'{}' Î™®Îç∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Ïö¥Î°úÎìú ÌôïÏù∏ Ï§ë...",
                "confirming_download": "Î™®Îç∏ Îã§Ïö¥Î°úÎìú ÌôïÏù∏ Ï§ë: {}",
                "unable_to_get_duration": "Ïò§ÎîîÏò§ Í∏∏Ïù¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§:",
                "downloading": "'{}' Î™®Îç∏ Îã§Ïö¥Î°úÎìú Ï§ë... (ÌÅ¨Í∏∞: {})",
                "loading": "'{}' Î™®Îç∏ Î°úÎìú Ï§ë...",
                "language_codes": {
                    "ja": "ÏùºÎ≥∏Ïñ¥",
                    "en": "ÏòÅÏñ¥",
                    "zh": "Ï§ëÍµ≠Ïñ¥", 
                    "ko": "ÌïúÍµ≠Ïñ¥",
                    "es": "Ïä§ÌéòÏù∏Ïñ¥",
                    "fr": "ÌîÑÎûëÏä§Ïñ¥",
                    "de": "ÎèÖÏùºÏñ¥",
                    "ru": "Îü¨ÏãúÏïÑÏñ¥",
                    "auto": "ÏûêÎèô Í∞êÏßÄ"
                }
            }
        }

    def t(self, key):
        """Get translated text for current language"""
        return self.translations.get(self.current_language, self.translations["en"]).get(key, key)

    def check_dependencies(self):
        """Check if PyTorch and Whisper are available"""
        global WHISPER_AVAILABLE
        
        if not setup_pytorch_path():
            WHISPER_AVAILABLE = False
        else:
            if torch and torch.cuda.is_available():
                self.device = "cuda"
            else:
                self.device = "cpu"

    def calculate_scaling(self):
        """Calculate scaling factors based on screen size"""
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        
        # Base dimensions for scaling (designed for 1920x1080)
        base_width = 1920
        base_height = 1080
        
        # Calculate scaling factors
        self.scale_x = screen_width / base_width
        self.scale_y = screen_height / base_height
        self.scale = min(self.scale_x, self.scale_y)  # Use minimum to maintain aspect ratio
        
        # Ensure minimum scaling
        self.scale = max(self.scale, 0.75)
        
        # Font scaling
        self.base_font_sizes = {
            'title': 22,
            'header': 13,
            'normal': 11,
            'small': 10
        }
        
        self.scaled_fonts = {}
        for key, size in self.base_font_sizes.items():
            self.scaled_fonts[key] = max(int(size * self.scale), 8)
        
        # Widget dimensions
        self.scaled_dimensions = {
            'window_width': int(1000 * self.scale),
            'window_height': int(1000 * self.scale),
            'min_width': int(800 * self.scale),
            'min_height': int(700 * self.scale),
            'padding_large': int(15 * self.scale),
            'padding_medium': int(12 * self.scale),
            'padding_small': int(8 * self.scale),
            'button_padding_x': int(20 * self.scale),
            'button_padding_y': int(10 * self.scale),
            'entry_padding': int(12 * self.scale),
            'progress_length': int(500 * self.scale),
            'output_height': int(8 * self.scale),
            'combo_width': int(30 * self.scale),
            'lang_combo_width': int(10 * self.scale)
        }

    def setup_responsive_gui(self):
        self.root = tk.Tk()
        self.root.title(self.t("window_title"))
        
        # Calculate scaling before setting up GUI
        self.calculate_scaling()
        
        # Set window size based on screen dimensions
        window_width = self.scaled_dimensions['window_width']
        window_height = self.scaled_dimensions['window_height']
        min_width = self.scaled_dimensions['min_width']
        min_height = self.scaled_dimensions['min_height']
        
        # Set minimum window size
        self.root.minsize(min_width, min_height)
        
        # Center window on screen
        self.root.geometry(f"{window_width}x{window_height}")
        self.root.update_idletasks()
        
        ws = self.root.winfo_screenwidth()
        hs = self.root.winfo_screenheight()
        x = (ws // 2) - (window_width // 2)
        y = (hs // 2) - (window_height // 2) - 20
        self.root.geometry(f"{window_width}x{window_height}+{x}+{y}")
        
        self.root.configure(bg=self.colors['background'])
        
        # Configure grid weights for responsive layout
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        
        # Style configuration
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.configure_responsive_styles()

        # Main container with responsive padding
        main = tk.Frame(self.root, bg=self.colors['background'])
        main.pack(fill=tk.BOTH, expand=True, 
                  padx=self.scaled_dimensions['padding_large'], 
                  pady=self.scaled_dimensions['padding_large'])

        # Create responsive sections
        self.create_responsive_header(main)
        self.create_responsive_file_section(main)
        
        if not WHISPER_AVAILABLE:
            self.create_responsive_dependency_warning(main)
            
        self.create_responsive_model_section(main)
        self.create_responsive_topic_section(main)
        self.create_responsive_status_section(main)
        self.create_responsive_transcription_output_section(main)
        self.create_responsive_save_section(main)

        # Bind resize event for dynamic updates
        self.root.bind('<Configure>', self.on_window_resize)
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.process_message_queue()
        self.update_status(self.t("waiting_to_start"), self.colors['text_light'])

    def on_window_resize(self, event=None):
        """Handle window resize events"""
        if hasattr(self, '_last_resize_time'):
            # Debounce resize events
            if time.time() - self._last_resize_time < 0.1:
                return
        self._last_resize_time = time.time()

    def configure_responsive_styles(self):
        """Configure styles with responsive dimensions"""
        button_pad_x = self.scaled_dimensions['button_padding_x']
        button_pad_y = self.scaled_dimensions['button_padding_y']
        
        self.style.configure('Primary.TButton',
                             background=self.colors['accent'],
                             foreground='white',
                             borderwidth=0,
                             focuscolor='none',
                             padding=(button_pad_x, button_pad_y),
                             font=('Yu Gothic', self.scaled_fonts['normal']))
        self.style.map('Primary.TButton',
                       background=[('active', '#4C7EA3'),
                                   ('pressed', '#3E6D8F')])
        
        self.style.configure('Success.TButton',
                             background=self.colors['success'],
                             foreground='white',
                             borderwidth=0,
                             focuscolor='none',
                             padding=(button_pad_x, button_pad_y),
                             font=('Yu Gothic', self.scaled_fonts['normal']))
        
        self.style.configure('Danger.TButton',
                             background=self.colors['danger'],
                             foreground='white',
                             borderwidth=0,
                             focuscolor='none',
                             padding=(button_pad_x, button_pad_y),
                             font=('Yu Gothic', self.scaled_fonts['normal']))
        
        entry_pad = self.scaled_dimensions['entry_padding']
        self.style.configure('Modern.TEntry',
                             fieldbackground=self.colors['surface'],
                             borderwidth=2,
                             relief='solid',
                             bordercolor=self.colors['border'],
                             padding=(entry_pad, entry_pad // 2),
                             font=('Yu Gothic', self.scaled_fonts['normal']))

    def create_responsive_header(self, parent):
        """Create header with responsive layout"""
        hf = tk.Frame(parent, bg=self.colors['background'])
        hf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_large']))
        
        # Create a frame for the subtitle and language selector
        title_frame = tk.Frame(hf, bg=self.colors['background'])
        title_frame.pack(fill=tk.X)
        
        # Left side - subtitle only
        left_frame = tk.Frame(title_frame, bg=self.colors['background'])
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.header_subtitle_label = tk.Label(
            left_frame, 
            text=self.t("header_subtitle"),
            font=('Segoe UI', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['background']
        )
        self.header_subtitle_label.pack()
        
        # Right side - language selector
        lang_frame = tk.Frame(title_frame, bg=self.colors['background'])
        lang_frame.pack(side=tk.RIGHT, padx=self.scaled_dimensions['padding_medium'])
        
        self.lang_label = tk.Label(
            lang_frame,
            text=self.t("language"),
            font=('Yu Gothic', self.scaled_fonts['small']),
            fg=self.colors['text'],
            bg=self.colors['background']
        )
        self.lang_label.pack(side=tk.LEFT, padx=(0, self.scaled_dimensions['padding_small'] // 2))
        
        # Language display names
        self.language_display = {
            "en": "en - English",
            "ja": "ja - Êó•Êú¨Ë™û",
            "zh": "cn - ‰∏≠Êñá",
            "ko": "ko - ÌïúÍµ≠Ïñ¥"
        }
        
        self.ui_language_var = tk.StringVar(value=self.language_display[self.current_language])
        self.language_combo = ttk.Combobox(
            lang_frame,
            textvariable=self.ui_language_var,
            values=list(self.language_display.values()),
            state="readonly",
            width=self.scaled_dimensions['lang_combo_width'],
            font=('Segoe UI', self.scaled_fonts['small'])
        )
        self.language_combo.pack(side=tk.LEFT)
        self.language_combo.bind("<<ComboboxSelected>>", self.on_language_change)

    def create_responsive_file_section(self, parent):
        """Create file section with responsive layout"""
        ff = tk.Frame(parent, bg=self.colors['surface'], relief='solid', bd=1)
        ff.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_medium']))
        
        inner = tk.Frame(ff, bg=self.colors['surface'])
        inner.pack(fill=tk.X, 
                   padx=self.scaled_dimensions['padding_large'], 
                   pady=self.scaled_dimensions['padding_medium'])
        
        # Header row with title on left and parameter button on right
        header_row = tk.Frame(inner, bg=self.colors['surface'])
        header_row.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.file_section_label = tk.Label(
            header_row, 
            text=self.t("audio_file_selection"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.file_section_label.pack(side=tk.LEFT)
        
        self.param_btn = ttk.Button(
            header_row,
            text=self.t("adjust_parameters"),
            command=self.open_parameter_window,
            style='Primary.TButton'
        )
        self.param_btn.pack(side=tk.RIGHT)
        
        btnf = tk.Frame(inner, bg=self.colors['surface'])
        btnf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_small']))
        
        self.select_file_btn = ttk.Button(
            btnf,
            text=self.t("select_file"),
            command=self.select_audio_file,
            style='Primary.TButton'
        )
        self.select_file_btn.pack(side=tk.LEFT, padx=(0, self.scaled_dimensions['padding_medium']))
        
        self.transcribe_btn = ttk.Button(
            btnf,
            text=self.t("start_transcription"),
            command=self.transcribe_audio,
            style='Success.TButton',
            state=tk.DISABLED if not WHISPER_AVAILABLE else tk.DISABLED
        )
        self.transcribe_btn.pack(side=tk.LEFT)
        
        self.file_path_label = tk.Label(
            inner,
            text=self.t("no_file_selected"),
            font=('Yu Gothic', self.scaled_fonts['small']),
            fg=self.colors['text_light'],
            bg=self.colors['surface']
        )
        self.file_path_label.pack(anchor=tk.W)


    def create_responsive_dependency_warning(self, parent):
        """Create responsive warning section for missing dependencies"""
        wf = tk.Frame(parent, bg=self.colors['warning'], relief='solid', bd=2)
        wf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_large']))
        
        inner = tk.Frame(wf, bg=self.colors['warning'])
        inner.pack(fill=tk.X, 
                   padx=self.scaled_dimensions['padding_large'], 
                   pady=self.scaled_dimensions['padding_medium'])
        
        self.dep_warning_label = tk.Label(
            inner, 
            text=self.t("dependency_warning"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg='white', 
            bg=self.colors['warning']
        )
        self.dep_warning_label.pack(anchor=tk.W, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.dep_message_label = tk.Label(
            inner, 
            text=self.t("dependency_message"),
            font=('Yu Gothic', self.scaled_fonts['normal']),
            fg='white', 
            bg=self.colors['warning']
        )
        self.dep_message_label.pack(anchor=tk.W, pady=(0, self.scaled_dimensions['padding_medium']))
        
        btn_frame = tk.Frame(inner, bg=self.colors['warning'])
        btn_frame.pack(anchor=tk.W)
        
        self.run_downloader_btn = ttk.Button(
            btn_frame,
            text=self.t("run_downloader"),
            command=self.run_pytorch_downloader
        )
        self.run_downloader_btn.pack(side=tk.LEFT, padx=(0, self.scaled_dimensions['padding_medium']))
        
        self.recheck_btn = ttk.Button(
            btn_frame,
            text=self.t("recheck"),
            command=self.recheck_dependencies
        )
        self.recheck_btn.pack(side=tk.LEFT)

    def create_responsive_model_section(self, parent):
        """Create model section with responsive layout"""
        mf = tk.Frame(parent, bg=self.colors['surface'], relief='solid', bd=1)
        mf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_medium']))
        
        inner = tk.Frame(mf, bg=self.colors['surface'])
        inner.pack(fill=tk.X, 
                   padx=self.scaled_dimensions['padding_large'], 
                   pady=self.scaled_dimensions['padding_medium'])
        
        self.model_section_label = tk.Label(
            inner, 
            text=self.t("whisper_model"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.model_section_label.pack(anchor=tk.W, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.model_var = tk.StringVar(value="large-v3")
        opts = ["tiny","base","small","medium","large","large-v2","large-v3","large-v3-turbo"]
        self.model_combo = ttk.Combobox(
            inner,
            textvariable=self.model_var,
            values=opts,
            font=('Yu Gothic', self.scaled_fonts['normal']),
            state="readonly" if WHISPER_AVAILABLE else "disabled",
            width=self.scaled_dimensions['combo_width']
        )
        self.model_combo.set("large-v3")
        self.model_combo.pack(fill=tk.X)

    def create_responsive_topic_section(self, parent):
        """Create topic section with responsive layout"""
        tf = tk.Frame(parent, bg=self.colors['surface'], relief='solid', bd=1)
        tf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_medium']))
        
        inner = tk.Frame(tf, bg=self.colors['surface'])
        inner.pack(fill=tk.X, 
                   padx=self.scaled_dimensions['padding_large'], 
                   pady=self.scaled_dimensions['padding_medium'])
        
        self.keyword_label = tk.Label(
            inner, 
            text=self.t("keyword_optional"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.keyword_label.pack(anchor=tk.W, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.topic_entry = ttk.Entry(inner, font=('Yu Gothic', self.scaled_fonts['normal']), style='Modern.TEntry')
        self.topic_entry.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_medium']))
        
        self.trans_lang_label = tk.Label(
            inner, 
            text=self.t("transcription_language"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.trans_lang_label.pack(anchor=tk.W, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.transcription_lang_var = tk.StringVar(value="ja")
        self.transcription_language_combo = ttk.Combobox(
            inner,
            textvariable=self.transcription_lang_var,
            font=('Yu Gothic', self.scaled_fonts['normal']),
            state="readonly" if WHISPER_AVAILABLE else "disabled",
            width=self.scaled_dimensions['combo_width']
        )
        self.update_language_combo()
        self.transcription_language_combo.pack(fill=tk.X)

    def create_responsive_status_section(self, parent):
        """Create status section with responsive layout"""
        sf = tk.Frame(parent, bg=self.colors['surface'], relief='solid', bd=1)
        sf.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_medium']))
        
        sin = tk.Frame(sf, bg=self.colors['surface'])
        sin.pack(fill=tk.X, 
                 padx=self.scaled_dimensions['padding_large'], 
                 pady=self.scaled_dimensions['padding_medium'])
        
        row = tk.Frame(sin, bg=self.colors['surface'])
        row.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_small']))
        
        self.status_section_label = tk.Label(
            row, 
            text=self.t("system_status"),
            font=('Yu Gothic', self.scaled_fonts['normal'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.status_section_label.pack(side=tk.LEFT)
        
        self.status_label = tk.Label(
            row,
            text=self.t("waiting_to_start"),
            font=('Yu Gothic', self.scaled_fonts['normal']),
            fg=self.colors['text_light'],
            bg=self.colors['surface']
        )
        self.status_label.pack(side=tk.RIGHT)
        
        self.progress_bar = ttk.Progressbar(
            sin, 
            length=self.scaled_dimensions['progress_length'], 
            mode='indeterminate'
        )
        self.progress_bar.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_small']))
        
        trow = tk.Frame(sin, bg=self.colors['surface'])
        trow.pack(fill=tk.X)
        
        self.elapsed_label = tk.Label(
            trow,
            text=f"{self.t('elapsed')} 00:00",
            font=('Yu Gothic', self.scaled_fonts['small']),
            fg=self.colors['text_light'],
            bg=self.colors['surface']
        )
        self.elapsed_label.pack(side=tk.LEFT)
        
        self.duration_label = tk.Label(
            trow,
            text=f"{self.t('duration')} 00:00",
            font=('Yu Gothic', self.scaled_fonts['small']),
            fg=self.colors['text_light'],
            bg=self.colors['surface']
        )
        self.duration_label.pack(side=tk.RIGHT)

    def create_responsive_transcription_output_section(self, parent):
        """Create the real-time transcription output section with responsive layout"""
        tf = tk.Frame(parent, bg=self.colors['surface'], relief='solid', bd=1)
        tf.pack(fill=tk.BOTH, expand=True, pady=(0, self.scaled_dimensions['padding_medium']))
        
        inner = tk.Frame(tf, bg=self.colors['surface'])
        inner.pack(fill=tk.BOTH, expand=True, 
                   padx=self.scaled_dimensions['padding_large'], 
                   pady=self.scaled_dimensions['padding_medium'])
        
        header_frame = tk.Frame(inner, bg=self.colors['surface'])
        header_frame.pack(fill=tk.X, pady=(0, self.scaled_dimensions['padding_small'] // 2))
        
        self.output_section_label = tk.Label(
            header_frame, 
            text=self.t("transcription_output"),
            font=('Yu Gothic', self.scaled_fonts['header'], 'bold'),
            fg=self.colors['text'], 
            bg=self.colors['surface']
        )
        self.output_section_label.pack(side=tk.LEFT)
        
        self.clear_output_btn = ttk.Button(
            header_frame,
            text=self.t("clear"),
            command=self.clear_transcription_output
        )
        self.clear_output_btn.pack(side=tk.RIGHT)
        
        # Calculate dynamic height for output text
        output_height = max(self.scaled_dimensions['output_height'], 6)
        
        self.output_text = scrolledtext.ScrolledText(
            inner,
            height=output_height,
            font=('Yu Gothic', self.scaled_fonts['small']),
            bg=self.colors['surface'],
            fg=self.colors['text'],
            wrap=tk.WORD,
            relief='solid',
            borderwidth=1,
            state=tk.DISABLED
        )
        self.output_text.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags with responsive fonts
        self.output_text.tag_configure(
            "timestamp", 
            foreground=self.colors['accent'], 
            font=('Yu Gothic', self.scaled_fonts['small'], 'bold')
        )
        self.output_text.tag_configure(
            "text", 
            foreground=self.colors['text']
        )
        self.output_text.tag_configure(
            "status", 
            foreground=self.colors['warning'], 
            font=('Yu Gothic', self.scaled_fonts['small'], 'italic')
        )

    def create_responsive_save_section(self, parent):
        """Create save section with responsive layout"""
        slf = tk.Frame(parent, bg=self.colors['background'])
        slf.pack(pady=self.scaled_dimensions['padding_small'])
        
        tf = tk.Frame(slf, bg=self.colors['background'])
        tf.pack(pady=(0, self.scaled_dimensions['padding_small']))
        
        self.save_transcription_btn = ttk.Button(
            tf,
            text=self.t("save_transcription"),
            command=self.save_transcription,
            style='Primary.TButton',
            state=tk.DISABLED
        )
        self.save_transcription_btn.pack(side=tk.LEFT, padx=(0, self.scaled_dimensions['padding_medium']))
        
        self.save_subtitle_btn = ttk.Button(
            tf,
            text=self.t("save_subtitle"),
            command=self.save_subtitle_file,
            style='Success.TButton',
            state=tk.DISABLED
        )
        self.save_subtitle_btn.pack(side=tk.LEFT)

    def open_parameter_window(self):
        """Open parameter settings window with responsive layout"""
        win = tk.Toplevel(self.root)
        win.title(self.t("parameter_settings"))
        
        # Calculate window size
        param_width = int(500 * self.scale)
        param_height = int(460 * self.scale)
        win.geometry(f"{param_width}x{param_height}")
        win.configure(bg=self.colors['surface'])
        
        # Center the parameter window
        win.update_idletasks()
        x = (win.winfo_screenwidth() // 2) - (param_width // 2)
        y = (win.winfo_screenheight() // 2) - (param_height // 2)
        win.geometry(f"{param_width}x{param_height}+{x}+{y}")
        
        pad = self.scaled_dimensions['padding_large']
        small_pad = self.scaled_dimensions['padding_small']
        
        # Temperature
        tk.Label(win, text="Temperature:",
                 bg=self.colors['surface'], 
                 fg=self.colors['text'],
                 font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))
        self.temp_var = tk.DoubleVar(value=0.0)
        tk.Scale(win, from_=0.0, to=1.0, resolution=0.01, orient=tk.HORIZONTAL,
                 variable=self.temp_var, 
                 font=('Yu Gothic', self.scaled_fonts['small'])).pack(fill=tk.X, padx=pad)

        # best_of
        tk.Label(win, text="best_of:",
                 bg=self.colors['surface'], 
                 fg=self.colors['text'],
                 font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))
        self.best_of_var = tk.IntVar(value=10)
        tk.Spinbox(win, from_=1, to=10, textvariable=self.best_of_var,
                   font=('Yu Gothic', self.scaled_fonts['normal'])).pack(fill=tk.X, padx=pad)

        # beam_size
        tk.Label(win, text="beam_size:",
                 bg=self.colors['surface'], 
                 fg=self.colors['text'],
                 font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))
        self.beam_var = tk.IntVar(value=10)
        tk.Spinbox(win, from_=1, to=20, textvariable=self.beam_var,
                   font=('Yu Gothic', self.scaled_fonts['normal'])).pack(fill=tk.X, padx=pad)

        # logprob_threshold
        tk.Label(win, text="logprob_threshold:",
                 bg=self.colors['surface'], 
                 fg=self.colors['text'],
                 font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))
        self.logp_var = tk.DoubleVar(value=-1)
        tk.Scale(win, from_=-5.0, to=0.0, resolution=0.1, orient=tk.HORIZONTAL,
                 variable=self.logp_var,
                 font=('Yu Gothic', self.scaled_fonts['small'])).pack(fill=tk.X, padx=pad)

        # no_speech_threshold
        tk.Label(win, text="no_speech_threshold:",
                 bg=self.colors['surface'], 
                 fg=self.colors['text'],
                 font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))
        self.nospeech_var = tk.DoubleVar(value=0.5)
        tk.Scale(win, from_=0.0, to=1.0, resolution=0.01, orient=tk.HORIZONTAL,
                 variable=self.nospeech_var,
                 font=('Yu Gothic', self.scaled_fonts['small'])).pack(fill=tk.X, padx=pad)

        # condition_on_previous_text
        self.cond_prev_var = tk.BooleanVar(value=False)
        tk.Checkbutton(win,
                       text="condition_on_previous_text",
                       variable=self.cond_prev_var,
                       bg=self.colors['surface'],
                       fg=self.colors['text'],
                       font=('Yu Gothic', self.scaled_fonts['normal'])).pack(anchor=tk.W, padx=pad, pady=(pad,0))

        # OK button
        def apply_params():
            self.whisper_params = {
                "temperature": self.temp_var.get(),
                "best_of": self.best_of_var.get(),
                "beam_size": self.beam_var.get(),
                "logprob_threshold": self.logp_var.get(),
                "no_speech_threshold": self.nospeech_var.get(),
                "condition_on_previous_text": self.cond_prev_var.get(),
            }
            win.destroy()
            self.append_status_message(f"{self.t('parameters_updated')} {self.whisper_params}")

        ttk.Button(win, text=self.t("ok"), command=apply_params, style='Success.TButton')\
            .pack(pady=self.scaled_dimensions['padding_large'])

    def on_language_change(self, event=None):
        """Handle language change event"""
        display_name = self.ui_language_var.get()
        for code, name in self.language_display.items():
            if name == display_name:
                self.current_language = code
                break
        self.update_all_texts()

    def update_all_texts(self):
        """Update all UI texts when language changes"""
        # Update window title
        self.root.title(self.t("window_title"))
        
        # Update header
        self.header_subtitle_label.config(text=self.t("header_subtitle"))
        self.lang_label.config(text=self.t("language"))
        
        # Update file section
        self.file_section_label.config(text=self.t("audio_file_selection"))
        self.select_file_btn.config(text=self.t("select_file"))
        self.transcribe_btn.config(text=self.t("start_transcription"))
        if not self.current_file:
            self.file_path_label.config(text=self.t("no_file_selected"))
        
        # Update parameter button
        self.param_btn.config(text=self.t("adjust_parameters"))
        
        # Update dependency warning if present
        if hasattr(self, 'dep_warning_label'):
            self.dep_warning_label.config(text=self.t("dependency_warning"))
            self.dep_message_label.config(text=self.t("dependency_message"))
            self.run_downloader_btn.config(text=self.t("run_downloader"))
            self.recheck_btn.config(text=self.t("recheck"))
        
        # Update model section
        self.model_section_label.config(text=self.t("whisper_model"))
        
        # Update topic section
        self.keyword_label.config(text=self.t("keyword_optional"))
        self.trans_lang_label.config(text=self.t("transcription_language"))
        self.update_language_combo()
        
        # Update status section
        self.status_section_label.config(text=self.t("system_status"))
        self.elapsed_label.config(text=f"{self.t('elapsed')} 00:00")
        if self.audio_duration > 0:
            duration_str = str(timedelta(seconds=int(self.audio_duration)))
            self.duration_label.config(text=f"{self.t('duration')} {duration_str}")
        else:
            self.duration_label.config(text=f"{self.t('duration')} 00:00")
        
        # Update transcription output section
        self.output_section_label.config(text=self.t("transcription_output"))
        self.clear_output_btn.config(text=self.t("clear"))
        
        # Update save section
        self.save_transcription_btn.config(text=self.t("save_transcription"))
        self.save_subtitle_btn.config(text=self.t("save_subtitle"))

    def update_language_combo(self):
        """Update transcription language combo box with translated names"""
        lang_codes = self.t("language_codes")
        langs = [
            f"ja - {lang_codes['ja']}",
            f"en - {lang_codes['en']}",
            f"zh - {lang_codes['zh']}",
            f"ko - {lang_codes['ko']}",
            f"es - {lang_codes['es']}",
            f"fr - {lang_codes['fr']}",
            f"de - {lang_codes['de']}",
            f"ru - {lang_codes['ru']}",
            f"auto - {lang_codes['auto']}"
        ]
        self.transcription_language_combo['values'] = langs
        self.transcription_language_combo.set(f"ja - {lang_codes['ja']}")

    def run_pytorch_downloader(self):
        """Launch PyTorch downloader"""
        downloader_path = Path("pytorch_downloader.exe")
        if not downloader_path.exists():
            downloader_path = Path("pytorch_downloader.py")
        
        if downloader_path.exists():
            try:
                if platform.system() == "Windows" and downloader_path.suffix == ".exe":
                    subprocess.Popen([str(downloader_path)])
                else:
                    subprocess.Popen([sys.executable, str(downloader_path)])
                messagebox.showinfo(self.t("info"), self.t("downloader_launched"))
            except Exception as e:
                messagebox.showerror(self.t("error"), f"{self.t('downloader_launch_failed')} {e}")
        else:
            messagebox.showerror(self.t("error"), self.t("downloader_not_found"))

    def recheck_dependencies(self):
        """Recheck PyTorch/Whisper availability"""
        self.check_dependencies()
        if WHISPER_AVAILABLE:
            messagebox.showinfo(self.t("success"), self.t("dependencies_loaded"))
            self.root.destroy()
            app = AudioSubtitleSystem()
            app.run()
        else:
            messagebox.showwarning(self.t("warning"), self.t("dependencies_not_installed"))

    def update_status(self, message, color=None):
        """Thread-safe status update"""
        if color is None:
            color = self.colors['accent']
        
        def update():
            self.status_label.config(text=message, fg=color)
        
        self.update_ui_safe(update)

    def append_status_message(self, message):
        """Append a status message to the transcription output"""
        def update():
            self.output_text.config(state=tk.NORMAL)
            
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.output_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
            self.output_text.insert(tk.END, f"{message}\n", "status")
            
            self.output_text.see(tk.END)
            self.output_text.config(state=tk.DISABLED)
            
        self.update_ui_safe(update)

    def append_transcription_text(self, start_time, end_time, text):
        """Append transcribed text to the output display"""
        def update():
            self.output_text.config(state=tk.NORMAL)
            self.output_text.insert(tk.END, f"[{start_time} --> {end_time}] ", "timestamp")
            self.output_text.insert(tk.END, f"{text}\n\n", "text")
            self.output_text.see(tk.END)
            self.output_text.config(state=tk.DISABLED)
            
        self.update_ui_safe(update)

    def append_transcription_text_with_offset(self, start_str, end_str, text, offset):
        def ts2s(ts):
            m, s = ts.split(':')
            return int(m) * 60 + float(s)
        start = ts2s(start_str) + offset
        end   = ts2s(end_str)   + offset
    
        def fmt(t):
            m = int(t // 60)
            s = t - m * 60
            return f"{m:02d}:{s:06.3f}"
        new_start = fmt(start)
        new_end   = fmt(end)
    
        self.output_text.config(state=tk.NORMAL)
        self.output_text.insert(tk.END, f"[{new_start} --> {new_end}] ", "timestamp")
        self.output_text.insert(tk.END, f"{text}\n\n", "text")
        self.output_text.see(tk.END)
        self.output_text.config(state=tk.DISABLED)

    def clear_transcription_output(self):
        """Clear the transcription output display"""
        def update():
            self.output_text.config(state=tk.NORMAL)
            self.output_text.delete(1.0, tk.END)
            self.output_text.config(state=tk.DISABLED)
        self.update_ui_safe(update)

    def get_audio_duration(self, file_path):
        """Get duration of audio file in seconds using whisper.load_audio for all formats."""
        if not WHISPER_AVAILABLE:
            messagebox.showerror(self.t("error"), self.t("whisper_not_installed"))
            return 0
            
        try:
            audio = whisper.load_audio(file_path)
            duration = audio.shape[0] / 16000.0
            return duration
        except Exception as e:
            messagebox.showerror(self.t("error"), f"{self.t('unable_to_get_duration')} {e}")
            return 0

    def select_audio_file(self):
        ftypes = [
            ("Audio files", "*.mp3 *.wav *.m4a *.aac *.ogg *.flac"), 
            ("All files", "*.*")
        ]
        fp = filedialog.askopenfilename(title="Select Audio File", filetypes=ftypes)
        if fp:
            self.current_file = fp
            self.file_path_label.config(text=os.path.basename(fp))
            
            if WHISPER_AVAILABLE:
                self.audio_duration = self.get_audio_duration(fp)
                duration_str = str(timedelta(seconds=int(self.audio_duration)))
                self.duration_label.config(text=f"{self.t('duration')} {duration_str}")
                self.transcribe_btn.config(state=tk.NORMAL)
                self.clear_transcription_output()
                self.append_status_message(self.t("file_selected").format(os.path.basename(fp), duration_str))
            else:
                self.append_status_message(self.t("file_selected_no_duration").format(os.path.basename(fp)))

    def check_model_exists(self, ms):
        cache_dir = Path.home()/".cache"/"whisper"
        return (cache_dir/f"{ms}.pt").exists()

    def load_whisper_model(self, model_size):
        if not WHISPER_AVAILABLE:
            self.update_ui_safe(lambda: messagebox.showerror(self.t("error"), self.t("whisper_not_installed")))
            return None
            
        model_sizes = {
            "tiny":  "~75 MB",
            "base":  "~142 MB",
            "small": "~466 MB",
            "medium":"~1.46 GB",
            "large": "~2.96 GB",
            "large-v2": "~2.96 GB",
            "large-v3": "~3.09 GB",
            "large-v3-turbo": "~1.6 GB"
        }
        
        if not self.check_model_exists(model_size):
            self.update_status(self.t("confirming_download").format(model_size), self.colors['warning'])
            self.append_status_message(self.t("model_not_found").format(model_size))
            
            self.message_queue.put(("ask_download", model_size, model_sizes.get(model_size)))
            
            response_queue = queue.Queue()
            self.model_download_response_queue = response_queue
            ok = response_queue.get()
            
            if not ok:
                self.update_status(self.t("model_download_cancelled"), self.colors['danger'])
                self.append_status_message(self.t("model_download_cancelled"))
                return None
            
            self.is_downloading = True
            self.update_status(self.t("downloading_model").format(model_size, model_sizes.get(model_size)), self.colors['warning'])
            self.append_status_message(self.t("downloading").format(model_size, model_sizes.get(model_size)))
                
        try:
            self.is_loading_model = True
            self.update_status(self.t("loading_model").format(model_size), self.colors['accent'])
            self.append_status_message(self.t("loading").format(model_size))
            
            # Save original stdout/stderr
            orig_stdout = sys.stdout
            orig_stderr = sys.stderr
            
            # Create a simple capture for model loading/downloading
            try:
                # Redirect output to avoid write errors during download
                sys.stdout = io.StringIO()
                sys.stderr = io.StringIO()
                
                # Load the model
                model = whisper.load_model(model_size, device=self.device)
                
            finally:
                # Always restore stdout/stderr
                sys.stdout = orig_stdout
                sys.stderr = orig_stderr
            
            self.is_downloading = False
            self.is_loading_model = False
            
            device_info = "GPU (CUDA)" if self.device == "cuda" else "CPU"
            self.append_status_message(self.t("model_loaded").format(model_size, device_info))
            
            return model
        except Exception as e:
            self.is_downloading = False
            self.is_loading_model = False
            err_msg = str(e)
            self.update_status(self.t("model_loading_error"), self.colors['danger'])
            self.append_status_message(f"{self.t('model_loading_error')}: {err_msg}")
            self.update_ui_safe(lambda err=err_msg: 
                messagebox.showerror(self.t("error"), f"{self.t('model_loading_failed')} {err}")
            )
            return None

    def process_message_queue(self):
        """Process messages from background threads"""
        try:
            while True:
                msg = self.message_queue.get_nowait()
                if msg[0] == "ask_download":
                    model_size = msg[1]
                    size_str = msg[2]
                    response = messagebox.askyesno(
                        self.t("model_download_title"),
                        self.t("model_download_confirm").format(model_size, size_str)
                    )
                    if hasattr(self, 'model_download_response_queue'):
                        self.model_download_response_queue.put(response)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.process_message_queue)

    def handle_segment_progress(self, current_seconds):
        """Handle progress updates based on transcribed segment timestamps"""
        if self.audio_duration > 0:
            progress_percentage = (current_seconds / self.audio_duration) * 100
            progress_percentage = min(progress_percentage, 100)
            
            def update_gui():
                elapsed = time.time() - self.transcription_start_time if self.transcription_start_time else 0
                elapsed_str = str(timedelta(seconds=int(elapsed)))
                self.elapsed_label.config(text=f"{self.t('elapsed')} {elapsed_str}")
                
            self.update_ui_safe(update_gui)

    def handle_progress_update(self, percentage, current_frames, total_frames, elapsed_str, remaining_str):
        """Handle progress updates from Whisper console output"""
        def update_gui():
            if elapsed_str:
                self.elapsed_label.config(text=f"{self.t('elapsed')} {elapsed_str}")
            
        self.update_ui_safe(update_gui)

    def update_elapsed_time(self):
        """Periodic update for elapsed time"""
        if self.is_transcribing and self.transcription_start_time:
            elapsed = time.time() - self.transcription_start_time
            elapsed_str = str(timedelta(seconds=int(elapsed)))
            self.elapsed_label.config(text=f"{self.t('elapsed')} {elapsed_str}")
            
            if self.is_downloading:
                status_text = f"{self.t('downloading_model').split(':')[0]}..."
            elif self.is_loading_model:
                status_text = f"{self.t('loading_model').split(':')[0]}..."
            else:
                status_text = f"{self.t('transcription_completed').split()[0]}..."
            
            self.update_status(status_text, self.colors['accent'])
            self.update_timer = self.root.after(1000, self.update_elapsed_time)
    
    def update_ui_safe(self, callback):
        """Safely update UI from any thread"""
        self.root.after(0, callback)
        
    def transcribe_audio(self):
        if not self.current_file:
            messagebox.showwarning(self.t("warning"), self.t("please_select_audio"))
            return
            
        if not WHISPER_AVAILABLE:
            messagebox.showerror(self.t("error"), self.t("whisper_not_installed"))
            return
            
        def task():
            self.update_ui_safe(lambda: self.transcribe_btn.config(state=tk.DISABLED))
            self.update_ui_safe(lambda: self.save_transcription_btn.config(state=tk.DISABLED))
            self.update_ui_safe(lambda: self.save_subtitle_btn.config(state=tk.DISABLED))
            
            self.update_ui_safe(self.clear_transcription_output)
            
            self.update_ui_safe(lambda: self.progress_bar.start(10))
            
            self.transcription_start_time = time.time()
            self.is_transcribing = True
            
            self.append_status_message(self.t("starting_transcription"))
            self.update_status(self.t("preparing"), self.colors['accent'])
            
            self.update_ui_safe(self.update_elapsed_time)

            lang = self.transcription_language_combo.get().split(' - ')[0]
            if lang == 'auto': 
                lang = None

            ms = self.model_combo.get()
            self.whisper_model = self.load_whisper_model(ms)
            if not self.whisper_model:
                self.is_transcribing = False
                self.is_downloading = False
                self.is_loading_model = False
                if self.update_timer:
                    self.root.after_cancel(self.update_timer)
                    self.update_timer = None
                self.update_ui_safe(lambda: self.progress_bar.stop())
                self.update_ui_safe(lambda: self.transcribe_btn.config(state=tk.NORMAL))
                self.update_status(self.t("model_loading_failed").split(':')[0], self.colors['danger'])
                return

            kw = self.topic_entry.get().strip()
            prompt = None
            if kw and lang:
                lang_prompts = {
                    'ja': f"„Åì„ÅÆÈü≥Â£∞„ÅØ„Äé{kw}„Äè„Å´Èñ¢ÈÄ£„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                    'en': f"The following audio is related to '{kw}'.",
                    'zh': f"‰ª•‰∏ãÈü≥È¢ë‰∏é'{kw}'Áõ∏ÂÖ≥„ÄÇ",
                    'ko': f"Îã§Ïùå Ïò§ÎîîÏò§Îäî '{kw}'ÏôÄ Í¥ÄÎ†®Ïù¥ ÏûàÏäµÎãàÎã§."
                }
                prompt = lang_prompts.get(lang, lang_prompts['en'])

            try:
                self.append_status_message(self.t("starting_transcription"))
                self.update_status(f"{self.t('transcription_completed').split()[0]}...", self.colors['accent'])
                
                self.transcription_results = []
                
                capture = ProgressCapture(
                    self.handle_progress_update,
                    self.handle_segment_progress,
                    self.append_transcription_text)
                orig_stdout, orig_stderr = sys.stdout, sys.stderr
                sys.stdout = sys.stderr = capture
                try:
                    audio = whisper.load_audio(self.current_file)
                    sr = 16000
                    chunk_size = 30 * 60 * sr
                    
                    segments_data = [
                        audio[i : i + chunk_size]
                        for i in range(0, audio.shape[0], chunk_size)
                    ]
                    
                    self.transcription_results = []
                    offset = 0.0
                    
                    for seg_index, seg_audio in enumerate(segments_data):
                        offset = seg_index * (chunk_size / sr)
                    
                        capture = ProgressCapture(
                            self.handle_progress_update,
                            self.handle_segment_progress,
                            lambda st, et, tx, off=offset: self.append_transcription_text_with_offset(st, et, tx, off)
                        )
                        orig_stdout, orig_stderr = sys.stdout, sys.stderr
                        sys.stdout = sys.stderr = capture
                    
                        params = getattr(self, 'whisper_params', {})
                        result_seg = self.whisper_model.transcribe(
                            seg_audio,
                            language=lang,
                            task="transcribe",
                            initial_prompt=prompt,
                            verbose=True,
                            temperature=params.get("temperature", 0.0),
                            best_of=params.get("best_of", 10),
                            beam_size=params.get("beam_size", 10),
                            logprob_threshold=params.get("logprob_threshold", -1),
                            no_speech_threshold=params.get("no_speech_threshold", 0.5),
                            condition_on_previous_text=params.get("condition_on_previous_text", False),
                            fp16=params.get("fp16", False)
                        )
                        sys.stdout, sys.stderr = orig_stdout, orig_stderr
                    
                        for seg in result_seg["segments"]:
                            self.transcription_results.append({
                                "start": seg["start"] + offset,
                                "end":   seg["end"]   + offset,
                                "text":  seg["text"].strip()
                            })

                        offset += seg_audio.shape[0] / sr
                    
                finally:
                    sys.stdout, sys.stderr = orig_stdout, orig_stderr
                
                self.update_ui_safe(lambda: self.progress_bar.stop())
                
                if self.transcription_start_time:
                    total_time = time.time() - self.transcription_start_time
                    elapsed_str = str(timedelta(seconds=int(total_time)))
                    self.update_ui_safe(lambda: self.elapsed_label.config(text=f"{self.t('elapsed')} {elapsed_str}"))
                
                self.append_status_message(self.t("transcription_complete").format(len(self.transcription_results), elapsed_str))
                
                self.update_status(self.t("transcription_completed"), self.colors['success'])
                self.update_ui_safe(lambda: self.transcribe_btn.config(state=tk.NORMAL))
                self.update_ui_safe(lambda: self.save_transcription_btn.config(state=tk.NORMAL))
                self.update_ui_safe(lambda: self.save_subtitle_btn.config(state=tk.NORMAL))
                self.update_ui_safe(lambda: messagebox.showinfo(self.t("success"), self.t("transcription_success")))
                
            except Exception as e:
                err_msg = str(e)
                self.update_ui_safe(lambda: self.progress_bar.stop())
                self.append_status_message(f"{self.t('transcription_error')} {err_msg}")
                self.update_ui_safe(lambda err=err_msg: 
                    messagebox.showerror(
                        self.t("error"),
                        f"{self.t('transcription_error')} {err}"
                    )
                )
                self.update_ui_safe(lambda: self.transcribe_btn.config(state=tk.NORMAL))
                self.update_status(self.t("error"), self.colors['danger'])
            finally:
                self.is_transcribing = False
                self.is_downloading = False
                self.is_loading_model = False
                if self.update_timer:
                    self.root.after_cancel(self.update_timer)
                    self.update_timer = None
                self.update_ui_safe(lambda: self.progress_bar.stop())
                
        threading.Thread(target=task, daemon=True).start()
    
    def save_transcription(self):
        if not self.transcription_results:
            messagebox.showwarning(self.t("warning"), self.t("no_results_to_save"))
            return
            
        fp = filedialog.asksaveasfilename(
            title=self.t("save_as"),
            defaultextension=".json",
            filetypes=[("JSON files","*.json"), ("Text files","*.txt"), ("All files","*.*")]
        )
        if not fp: 
            return
            
        try:
            if fp.endswith('.json'):
                data = {
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "source_file": os.path.basename(self.current_file),
                    "keyword": self.topic_entry.get().strip(),
                    "language": self.transcription_language_combo.get(),
                    "model": self.model_combo.get(),
                    "device": self.device,
                    "transcription": self.transcription_results
                }
                with open(fp, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
            else:
                with open(fp, 'w', encoding='utf-8') as f:
                    f.write(f"Transcription of: {os.path.basename(self.current_file)}\n")
                    f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"Language: {self.transcription_language_combo.get()}\n")
                    f.write(f"Model: {self.model_combo.get()}\n")
                    f.write("-" * 50 + "\n\n")
                    
                    for seg in self.transcription_results:
                        start_time = str(timedelta(seconds=int(seg['start'])))
                        end_time = str(timedelta(seconds=int(seg['end'])))
                        f.write(f"[{start_time} --> {end_time}]\n")
                        f.write(f"{seg['text']}\n\n")
                        
            self.append_status_message(f"{self.t('results_saved')} {os.path.basename(fp)}")
            messagebox.showinfo(self.t("success"), f"{self.t('results_saved')} {os.path.basename(fp)}")
        except Exception as e:
            messagebox.showerror(self.t("error"), f"{self.t('save_error')} {str(e)}")

    def save_subtitle_file(self):
        if not self.transcription_results:
            messagebox.showwarning(self.t("warning"), self.t("no_subtitles"))
            return
            
        fp = filedialog.asksaveasfilename(
            title=self.t("save_as"),
            defaultextension=".srt",
            filetypes=[("SRT files","*.srt"), ("VTT files","*.vtt"), ("All files","*.*")]
        )
        if not fp: 
            return
            
        try:
            if fp.endswith('.srt'):
                with open(fp, 'w', encoding='utf-8') as f:
                    for i, seg in enumerate(self.transcription_results, 1):
                        start_time = self.seconds_to_srt_time(seg['start'])
                        end_time = self.seconds_to_srt_time(seg['end'])
                        
                        f.write(f"{i}\n")
                        f.write(f"{start_time} --> {end_time}\n")
                        f.write(f"{seg['text']}\n\n")
                        
            elif fp.endswith('.vtt'):
                with open(fp, 'w', encoding='utf-8') as f:
                    f.write("WEBVTT\n\n")
                    for seg in self.transcription_results:
                        start_time = self.seconds_to_vtt_time(seg['start'])
                        end_time = self.seconds_to_vtt_time(seg['end'])
                        
                        f.write(f"{start_time} --> {end_time}\n")
                        f.write(f"{seg['text']}\n\n")
                        
            self.append_status_message(f"{self.t('subtitle_saved')} {os.path.basename(fp)}")
            messagebox.showinfo(self.t("success"), f"{self.t('subtitle_saved')} {os.path.basename(fp)}")
        except Exception as e:
            messagebox.showerror(self.t("error"), f"{self.t('save_error')} {str(e)}")

    def seconds_to_srt_time(self, seconds):
        """Convert seconds to SRT timestamp format (HH:MM:SS,mmm)"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

    def seconds_to_vtt_time(self, seconds):
        """Convert seconds to WebVTT timestamp format (HH:MM:SS.mmm)"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"

    def on_closing(self):
        if self.update_timer:
            self.root.after_cancel(self.update_timer)
        if self.original_stderr:
            sys.stderr = self.original_stderr
        self.root.destroy()

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    setup_pytorch_path()
    app = AudioSubtitleSystem()
    try:
        app.run()
    except KeyboardInterrupt:
        sys.exit(1)